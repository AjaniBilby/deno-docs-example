/**
 * Creates an array of specified length by calling a function for each index.
 *
 * @template T The type of elements in the resulting array
 * @param length The length of the array to create
 * @param f A function that takes an index and returns a value for that position
 * @returns A new array of the specified length with values generated by the function
 *
 * @example
 * // Create an array of squares: [0, 1, 4, 9, 16]
 * const squares = MakeArray(5, i => i * i);
 *
 * @example
 * // Create an array of strings: ["item0", "item1", "item2"]
 * const items = MakeArray(3, i => `item${i}`);
 */
export function MakeArray<T>(length: number, f: (index: number) => T) {
	return Array.from({ length }, (_, index) => f(index))
}


/**
 * Splits an array into segments using a separator value. The separator values are removed
 * from the result, and each segment becomes a separate array.
 *
 * @template T The type of elements in the input array
 * @template U The type of the separator value (must extend T)
 * @param arr The array to segment
 * @param split The value to use as a separator
 * @returns An array of arrays, where each sub-array is a segment between separators
 *
 * @example
 * // Split by comma: [["a", "b"], ["c", "d"], ["e"]]
 * const segments = SegmentArray(["a", "b", ",", "c", "d", ",", "e"], ",");
 *
 * @example
 * // Split numbers by zero: [[1, 2], [3, 4], [5]]
 * const segments = SegmentArray([1, 2, 0, 3, 4, 0, 5], 0);
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function SegmentArray<T, U extends T>(arr: Array<T>, split: U): Array<Array<Exclude<T, U>>> {
	const out: Array<Array<Exclude<T, U>>> = [[]];

	for (const v of arr) {
		if (v === split) out.push([]);
		else out[out.length-1].push(v as Exclude<T, U>);
	}

	return out;
}


/**
 * Splits an array into chunks of a specified size. The last chunk may be smaller
 * if the array length is not evenly divisible by the chunk size.
 *
 * @template T The type of elements in the array
 * @param array The array to chunk
 * @param size The size of each chunk (must be positive)
 * @returns An array of arrays, where each sub-array has at most `size` elements
 *
 * @example
 * // Chunk into groups of 2: [[1, 2], [3, 4], [5]]
 * const chunks = ChunkArray([1, 2, 3, 4, 5], 2);
 *
 * @example
 * // Chunk strings: [["a", "b", "c"], ["d", "e"]]
 * const chunks = ChunkArray(["a", "b", "c", "d", "e"], 3);
 */
export function ChunkArray<T>(array: T[], size: number): T[][] {
	const chunked: T[][] = [];
	for (let i = 0; i < array.length; i += size) {
		chunked.push(array.slice(i, i + size));
	}
	return chunked;
}



/**
 * Partitions an array into two arrays based on a predicate function.
 * Returns a tuple where the first array contains elements that failed the test
 * and the second array contains elements that passed the test.
 *
 * @template T The type of elements in the array
 * @param arr The array to partition
 * @param rule A predicate function that returns true for elements to include in the second array
 * @returns A tuple [falseArray, trueArray] where falseArray contains elements that failed the test
 *          and trueArray contains elements that passed the test
 *
 * @example
 * // Partition numbers into odd and even: [[2, 4], [1, 3, 5]]
 * const [evens, odds] = PartitionArray([1, 2, 3, 4, 5], x => x % 2 === 1);
 *
 * @example
 * // Partition strings by length: [["hi"], ["hello", "world"]]
 * const [short, long] = PartitionArray(["hello", "hi", "world"], s => s.length > 3);
 */
export function PartitionArray<T>(arr: T[], rule: (v: T) => boolean): [T[], T[]] {
	const t = new Array<T>();
	const f = new Array<T>();

	for (const item of arr) {
		if (rule(item)) t.push(item);
		else f.push(item);
	}

	return [f, t];
}